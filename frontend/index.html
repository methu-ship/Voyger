<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Stylus Invoices</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
</head>
<body class="bg-light">
  <div class="container py-4">
    <h1 class="mb-3">Stylus Invoice DApp</h1>

    <div class="card mb-3">
      <div class="card-body d-flex justify-content-between align-items-center">
        <div>
          <div><strong>Status:</strong> <span id="status">Not connected</span></div>
          <div><strong>Account:</strong> <span id="account">—</span></div>
          <div><strong>Chain:</strong> <span id="chain">—</span></div>
        </div>
        <button id="connectBtn" class="btn btn-primary">Connect Wallet</button>
      </div>
    </div>

    <div class="row g-3">
      <div class="col-md-6">
        <div class="card h-100">
          <div class="card-header">Create Invoice</div>
          <div class="card-body">
            <div class="mb-3">
              <label class="form-label">Recipient (0x...)</label>
              <input id="recipient" class="form-control" placeholder="0xRecipient" />
            </div>
            <div class="mb-3">
              <label class="form-label">Amount (ETH)</label>
              <input id="amountEth" class="form-control" placeholder="e.g. 1.0" />
              <small class="form-text text-muted">Will be converted to wei automatically</small>
            </div>
            <button id="createBtn" class="btn btn-success">Create</button>
            <div class="mt-2 small text-muted" id="createResult"></div>
          </div>
        </div>
      </div>

      <div class="col-md-6">
        <div class="card h-100">
          <div class="card-header">Mark Invoice as Paid</div>
          <div class="card-body">
            <div class="mb-3">
              <label class="form-label">Invoice ID</label>
              <input id="invoiceIdToPay" class="form-control" placeholder="e.g. 1" />
            </div>
            <button id="payBtn" class="btn btn-warning">Mark as Paid</button>
            <div class="mt-2 small text-muted" id="payResult"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card mt-3">
      <div class="card-header">My Invoices</div>
      <div class="card-body">
        <button id="refreshBtn" class="btn btn-outline-primary btn-sm mb-3">Refresh</button>
        <div class="table-responsive">
          <table class="table table-sm table-striped">
            <thead>
              <tr>
                <th>ID</th>
                <th>Status</th>
                <th>Amount (ETH)</th>
                <th>Actions</th>
              </tr>
            </thead>
            <tbody id="invoicesTable"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
  <script>
        // Provider will be created in the connect() function
    // 1) Set your deployment values
    const CONTRACT_ADDRESS = "0x18c858bcc8944e714e38323191e8bebaa6b9f3e0"; // Use address from ABI file
    const EXPECTED_CHAIN_ID_HEX = "0x66eee"; // Arbitrum One chain id in hex (42161 = 0xa4b1)
    // ABI matching the actual Stylus contract (snake_case functions)
    const CONTRACT_ABI = [
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "recipient_address",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256"
          }
        ],
        "name": "create_invoice",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "invoice_id",
            "type": "uint256"
          }
        ],
        "name": "mark_invoice_as_paid",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "invoice_id",
            "type": "uint256"
          }
        ],
        "name": "get_invoice_status",
        "outputs": [
          {
            "internalType": "uint8",
            "name": "",
            "type": "uint8"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "address",
            "type": "address"
          }
        ],
        "name": "get_invoices_for_address",
        "outputs": [
          {
            "internalType": "uint256[]",
            "name": "",
            "type": "uint256[]"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "invoice_id",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "address",
            "type": "address"
          }
        ],
        "name": "is_invoice_owner",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "get_total_invoices",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "address",
            "type": "address"
          },
          {
            "internalType": "uint8",
            "name": "status",
            "type": "uint8"
          }
        ],
        "name": "get_invoices_by_status_for_address",
        "outputs": [
          {
            "internalType": "uint256[]",
            "name": "",
            "type": "uint256[]"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "address",
            "type": "address"
          }
        ],
        "name": "get_invoice_count_for_address",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "name": "InvoiceDoesNotExist",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "name": "UnauthorizedAccess",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "name": "InvoiceAlreadyPaid",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ],
        "name": "InvalidAmount",
        "type": "error"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "name": "InvalidAddress",
        "type": "error"
      }
    ];
      

     let provider, signer, contract, currentAccount;

    async function ensureChain() {
      if (!window.ethereum) {
        throw new Error("MetaMask not found. Please install MetaMask.");
      }
      
      try {
        const chainId = await window.ethereum.request({ method: "eth_chainId" });
        console.log("Current chain ID:", chainId);
        document.getElementById("chain").textContent = chainId;
        
        if (EXPECTED_CHAIN_ID_HEX && chainId.toLowerCase() !== EXPECTED_CHAIN_ID_HEX.toLowerCase()) {
          throw new Error(`Please switch to Arbitrum One network. Current: ${chainId}, Expected: ${EXPECTED_CHAIN_ID_HEX}`);
        }
      } catch (error) {
        if (error.message.includes("eth_chainId")) {
          throw new Error("MetaMask is not connected. Please connect your wallet first.");
        }
        throw error;
      }
    }

    async function connect() {
        console.log("Connecting...", window.ethereum);
      if (!window.ethereum) {
        throw new Error("MetaMask not found");
      }
      await ensureChain();
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      currentAccount = accounts[0];
      document.getElementById("account").textContent = currentAccount;
      provider = new ethers.BrowserProvider(window.ethereum);
      signer = await provider.getSigner();
      
      // Check network and contract
      const network = await provider.getNetwork();
      console.log("Connected to network:", network);
      
      const code = await provider.getCode(CONTRACT_ADDRESS);
      console.log("Contract code at", CONTRACT_ADDRESS, ":", code === "0x" ? "NOT FOUND" : "FOUND");
      
      if (code === "0x") {
        throw new Error(`Contract not found at ${CONTRACT_ADDRESS}. Please check the address and network.`);
      }
      
      contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
      document.getElementById("status").textContent = "Connected";
      
      // Auto-refresh invoices when connected
      refreshInvoices();
    }

    // Helper function to validate Ethereum address
    function isValidAddress(address) {
      return /^0x[a-fA-F0-9]{40}$/.test(address);
    }

    // Helper function to validate ETH amount
    function isValidAmount(amount) {
      const num = parseFloat(amount);
      return !isNaN(num) && num > 0;
    }

    async function createInvoice() {
      const recipient = document.getElementById("recipient").value.trim();
      const amountEth = document.getElementById("amountEth").value.trim();
      const out = document.getElementById("createResult");
      
      // Check if contract is initialized
      if (!contract) {
        out.textContent = "Error: Please connect your wallet first";
        return;
      }

      // Validate inputs
      if (!recipient) {
        out.textContent = "Error: Please enter recipient address";
        return;
      }

      if (!isValidAddress(recipient)) {
        out.textContent = "Error: Invalid recipient address format";
        return;
      }

      if (!amountEth) {
        out.textContent = "Error: Please enter amount";
        return;
      }

      if (!isValidAmount(amountEth)) {
        out.textContent = "Error: Invalid amount (must be > 0)";
        return;
      }
      
      out.textContent = "Converting ETH to wei and submitting...";
      try {
        // Convert ETH to wei
        const amountWei = ethers.parseEther(amountEth);
        console.log("Calling create_invoice with:", { 
          recipient, 
          amountWei: amountWei.toString(),
          contractAddress: CONTRACT_ADDRESS,
          chainId: await provider.getNetwork().then(n => n.chainId)
        });
        
        // First check if contract exists
        const code = await provider.getCode(CONTRACT_ADDRESS);
        if (code === "0x") {
          throw new Error("Contract not found at address. Please check the contract address and network.");
        }
        
        const tx = await contract.create_invoice(recipient, amountWei);
        out.textContent = "Pending tx: " + tx.hash;
        const receipt = await tx.wait();
        out.textContent = "✅ Invoice created! Block: " + receipt.blockNumber + " | ID: " + receipt.logs[0]?.args?.invoice_id || "Check transaction";
        
        // Clear form
        document.getElementById("recipient").value = "";
        document.getElementById("amountEth").value = "";
        
        // Refresh invoice list
        setTimeout(refreshInvoices, 1000);
      } catch (e) {
        console.error("Create invoice error:", e);
        out.textContent = "Error: " + (e?.message || e);
      }
    }

    async function markAsPaid() {
      const idStr = document.getElementById("invoiceIdToPay").value.trim();
      const out = document.getElementById("payResult");
      
      if (!contract) {
        out.textContent = "Error: Please connect your wallet first";
        return;
      }

      if (!idStr) {
        out.textContent = "Error: Please enter invoice ID";
        return;
      }

      const invoiceId = parseInt(idStr);
      if (isNaN(invoiceId) || invoiceId <= 0) {
        out.textContent = "Error: Invalid invoice ID (must be a positive number)";
        return;
      }
      
      out.textContent = "Submitting...";
      try {
        const tx = await contract.mark_invoice_as_paid(invoiceId);
        out.textContent = "Pending tx: " + tx.hash;
        const receipt = await tx.wait();
        out.textContent = "✅ Invoice marked as paid! Block: " + receipt.blockNumber;
        
        // Clear form
        document.getElementById("invoiceIdToPay").value = "";
        
        // Refresh invoice list
        setTimeout(refreshInvoices, 1000);
      } catch (e) {
        console.error("Mark as paid error:", e);
        out.textContent = "Error: " + (e?.message || e);
      }
    }

    async function refreshInvoices() {
      const table = document.getElementById("invoicesTable");
      table.innerHTML = "";
      
      if (!currentAccount) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="2" class="text-muted">Please connect your wallet first</td>`;
        table.appendChild(tr);
        return;
      }
      
      if (!contract) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="2" class="text-danger">Error: Contract not initialized</td>`;
        table.appendChild(tr);
        return;
      }

      try {
        const ids = await contract.get_invoices_for_address(currentAccount);
        
        if (ids.length === 0) {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td colspan="4" class="text-muted text-center">No invoices found</td>`;
          table.appendChild(tr);
          return;
        }

        for (const id of ids) {
          const status = await contract.get_invoice_status(id);
          const statusText = Number(status) === 0 ? "Pending" : Number(status) === 1 ? "Paid" : "Unknown";
          const statusClass = Number(status) === 0 ? "text-warning" : Number(status) === 1 ? "text-success" : "text-muted";
          
          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td><strong>#${id.toString()}</strong></td>
            <td><span class="${statusClass}">${statusText}</span></td>
            <td>Loading...</td>
            <td>
              ${Number(status) === 0 ? 
                `<button class="btn btn-sm btn-outline-warning" onclick="markInvoiceAsPaid(${id})">Mark as Paid</button>` : 
                `<span class="text-muted">Completed</span>`
              }
            </td>
          `;
          table.appendChild(tr);
        }
      } catch (e) {
        const tr = document.createElement("tr");
        tr.innerHTML = `<td colspan="4" class="text-danger">Error: ${(e?.message || e)}</td>`;
        table.appendChild(tr);
      }
    }

    // Global function for inline button clicks
    window.markInvoiceAsPaid = async function(invoiceId) {
      document.getElementById("invoiceIdToPay").value = invoiceId;
      await markAsPaid();
    };

    // Wire up UI
    document.getElementById("connectBtn").addEventListener("click", async () => {
      try { 
        await connect(); 
    } catch (e) {
        
         alert(e?.message || e); }
    });
    document.getElementById("createBtn").addEventListener("click", createInvoice);
    document.getElementById("payBtn").addEventListener("click", markAsPaid);
    document.getElementById("refreshBtn").addEventListener("click", refreshInvoices);

    // Check if MetaMask is available on page load
    window.addEventListener('load', () => {
      if (!window.ethereum) {
        document.getElementById("status").textContent = "MetaMask not found";
        document.getElementById("connectBtn").disabled = true;
        document.getElementById("connectBtn").textContent = "Install MetaMask";
      } else {
        document.getElementById("status").textContent = "Ready to connect";
        // Try to auto-connect if already connected
        checkConnection();
      }
    });

    // Check if already connected
    async function checkConnection() {
      try {
        const accounts = await window.ethereum.request({ method: "eth_accounts" });
        if (accounts.length > 0) {
          currentAccount = accounts[0];
          document.getElementById("account").textContent = currentAccount;
          provider = new ethers.BrowserProvider(window.ethereum);
          signer = await provider.getSigner();
          contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
          document.getElementById("status").textContent = "Connected";
          refreshInvoices();
        }
      } catch (e) {
        console.log("Not connected:", e.message);
      }
    }

    // Auto-update account/chain changes
    if (window.ethereum) {
      window.ethereum.on("accountsChanged", () => location.reload());
      window.ethereum.on("chainChanged", () => location.reload());
    }
  </script>
</body>
</html>